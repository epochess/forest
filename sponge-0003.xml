<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:addr
type="user">sponge-0003</fr:addr><fr:route>sponge-0003.xml</fr:route><fr:title
text="Sponge Lab 1">Sponge Lab 1</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="epoche.xml"
addr="epoche"
title="Epoche">Epoche</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</fr:p><fr:p>Reassembler receive a substring that no more than about 1,460 bytes apiece, consisting of a string of bytes, and the index of the first byte of that string within the larger byte stream. Every byte in stream has index. As soon as reassembler find the next byte of the stream,  it will put the byte in the byte stream to keep data in order.</fr:p><fr:p>This lab requires a data structure that allows internal bytes to be arranged in order. Firstly, pushing the byte with index 0, and then pushing byte in which the precursor byte has been pushed. I to do this with vector, just like counting sort, I set a vector whose max length is the number of bytes in bytestream, and when I get a substring, I put each byte into the vector, the index of the bytes in the vector is the index of the byte stream.</fr:p><fr:p>Considering the implementation of the function, when I get a string, I put it into reassembler buffer. If the first byte index of the string is less than or equal to the next expect index (initial to 0), traverse buffer from the next expect index to the end of buffer, find the bytes that continuous starting at next expect byte and push to the bytestream. Otherwise, don't traverse.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>269</fr:anchor><fr:addr
type="user">sponge-0001</fr:addr><fr:route>sponge-0001.xml</fr:route><fr:title
text="Sponge Lab Notes">Sponge Lab Notes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="epoche.xml"
addr="epoche"
title="Epoche">Epoche</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:addr
type="user">sponge-0002</fr:addr><fr:route>sponge-0002.xml</fr:route><fr:title
text="Sponge Lab 0">Sponge Lab 0</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="epoche.xml"
addr="epoche"
title="Epoche">Epoche</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>Task 1: Webget</fr:strong><fr:p>To implement a byte stream based on the reliable transmission interface (TCP socket protocol) provided by the system. In pratice, it uses the TCP Socket API such as <fr:code>connect</fr:code> to establish a connection with server, <fr:code>write</fr:code> to write some information to the bytestream, <fr:code>read</fr:code> to read some information from the bytestream, and <fr:code>close</fr:code> the socket communication finally.</fr:p><fr:strong>Task 2: In Memory Byte Stream</fr:strong><fr:p>Task 2 is require us to maintain a container that can push some element to the container's back, and take some element from the front. So we can use queue, however, the effciency of the queue is very bad when we peek some bytes of certain length,  because in this function we just view them rather than pop them out. In this way, we can use deuqe to access its internal element, the use <fr:code>[]</fr:code> operator,  which has only <fr:tex
display="inline"><![CDATA[O(1)]]></fr:tex> time complexity.</fr:p><fr:p>In Minnow, <fr:link
type="external"
href="https://github.com/epochess/Sponge/blob/master/libsponge/byte_stream.cc">this implementation</fr:link> can achieve a throughput of 18Gbit/s.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:addr
type="user">sponge-0003</fr:addr><fr:route>sponge-0003.xml</fr:route><fr:title
text="Sponge Lab 1">Sponge Lab 1</fr:title><fr:date><fr:year>2024</fr:year><fr:month>9</fr:month><fr:day>17</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="epoche.xml"
addr="epoche"
title="Epoche">Epoche</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</fr:p><fr:p>Reassembler receive a substring that no more than about 1,460 bytes apiece, consisting of a string of bytes, and the index of the first byte of that string within the larger byte stream. Every byte in stream has index. As soon as reassembler find the next byte of the stream,  it will put the byte in the byte stream to keep data in order.</fr:p><fr:p>This lab requires a data structure that allows internal bytes to be arranged in order. Firstly, pushing the byte with index 0, and then pushing byte in which the precursor byte has been pushed. I to do this with vector, just like counting sort, I set a vector whose max length is the number of bytes in bytestream, and when I get a substring, I put each byte into the vector, the index of the bytes in the vector is the index of the byte stream.</fr:p><fr:p>Considering the implementation of the function, when I get a string, I put it into reassembler buffer. If the first byte index of the string is less than or equal to the next expect index (initial to 0), traverse buffer from the next expect index to the end of buffer, find the bytes that continuous starting at next expect byte and push to the bytestream. Otherwise, don't traverse.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>